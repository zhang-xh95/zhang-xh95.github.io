[{"title":"Muduo学习笔记之Channel","date":"2023-09-15T13:12:47.000Z","path":"2023/09/15/Muduo学习笔记之Channel/","text":"此学习笔记主要记录对Muduo源码的理解，主要参考陈硕的《Linux多线程服务端编程》，其他的参考资料会列于笔记末尾。水平有限，若有错误请在我的阅读笔记项目中指出。如果觉得写得还不错，可以点个小星星。 Channel类对象Channel对象负责一个文件描述符fd的IO事件监听及分发，但fd的生命周期不受Channel管理，因此不会在析构时关闭fd。用户不直接使用Channel，而是利用更上层的封装，例如TcpConnection。Channel涉及的主要时序如下： EventLoop::loop()函数会调用Poller::poll()函数，返回一个包含当前激活的Channel（发生了监听的events or 错误），然后逐个调用激活Channel的handleEvent()函数（实际会调用handleEventWithGuard完成），进行不同事件的处理。 Channel一般是其他类的直接或间接成员，生命周期由OwnerClass管理。举个栗子，EventLoop的成员wakeupChannel_通过std::unique&lt;Channel&gt;智能指针管理Channel的生命周期，这个Channel是用于唤醒(EventLoop)线程的，具体可见EventLoop分析笔记。 Channel的两大主要职责: IO事件监听：监听过程由Poller完成，可见Poller分析笔记。Channel给Poller提供目标文件描述符fd需要监听的事件，例如可读事件POLLIN，可写事件POLLOUT等。其实也就是设置pollfd events相关的内容(这里以poll为例)： 123456// POLL(2) Linux Programmer&#x27;s Mannualstruct pollfd &#123; int fd; /* 文件描述符 */ short events; /* 感兴趣的事件类型*/ short revents; /* 发生的事件类型 */&#125;; 当然了，Channel需要提供一些接口给user设置需要监听的事件类型，通过各种enable*和disable*成员函数搞定，具体见后面源码分析。 IO事件分发： Channel所监听事件rvents发生后，Poller通过Channel::set_revents(int revt)设置Channel::revents_成员变量。后续执行哪些事情(执行回调函数)通过Channel::handleEvent分发，例如fd可写后，会调用writeCallback。writeCallback这些回调函数也通过Channel::set*Callback接口进行设置。 1void set_revents(int revt) &#123; revents_ = revt; &#125; Channel源码分析Channel类对象重要成员： 监听事件管理： enableReading()： 开启读事件监听 enableWriting()：开启写事件监听 disableReading() ：关闭读事件监听 disableWriting()：关闭写事件监听 disableAll()：关闭读写事件监听 以读事件代码为例： 1234567891011121314151617181920const int Channel::kReadEvent = POLLIN | POLLPRI;const int Channel::kWriteEvent = POLLOUT; void Channel::enableReading() &#123; events_ |= kReadEvent; update(); &#125; void Channel::disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125; void Channel::update() &#123; addedToLoop_ = true; loop_-&gt;updateChannel(this); &#125; 回调函数设置： 1234void setReadCallback(ReadEventCallback cb)&#123; readCallback_ = std::move(cb); &#125;void setWriteCallback(EventCallback cb)&#123; writeCallback_ = std::move(cb); &#125; handleEvent事件处理 事件分发的主要逻辑，即根据revents_的内容调用不同的回调函数。 1234567891011121314151617181920212223242526272829void Channel::handleEventWithGuard(Timestamp receiveTime)&#123; eventHandling_ = true; // the peer closed its end of the channel and // no data to read if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN)) &#123; if (closeCallback_) closeCallback_(); &#125; // error condition or // invalid request: fd not open if (revents_ &amp; (POLLERR | POLLNVAL)) &#123; if (errorCallback_) errorCallback_(); &#125; // there is data to read or // urgent data to read or // stream socket peer closed connection, or shut down writing half of connection. if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP)) &#123; if (readCallback_) readCallback_(receiveTime); &#125; // writing is now possible if (revents_ &amp; POLLOUT) &#123; if (writeCallback_) writeCallback_(); &#125; eventHandling_ = false;&#125; tie weak_ptr： 1234567891011121314151617181920212223242526272829303132 /* * tie是weak_ptr: 目的是防止Owener Object在Channel执行handleEvent的时候被析构了 * handleEvent中执行的回调函数其实是TcpConnection中的成员函数，如果析构了就G * Muduo中Owner Object其实就是TcpConnection * 当然Owenner Object必须是由shared_ptr管理的 */ void Channel::tie(const std::shared_ptr&lt;void&gt;&amp; obj)&#123; tie_ = obj; tied_ = true;&#125;/* * 防止的手段就是weak_ptr.lock()尝试提升为shared_ptr * 提升不成功说明已经被析构了 就不执行handleEventWithGuard * 提升成功Owner Object不会在handleEventWithGuard中被析构 */void Channel::handleEvent(Timestamp receiveTime)&#123; std::shared_ptr&lt;void&gt; guard; if (tied_) &#123; guard = tie_.lock(); if (guard) &#123; handleEventWithGuard(receiveTime); &#125; &#125; else &#123; handleEventWithGuard(receiveTime); &#125;&#125;","link":"","tags":[{"name":"C++ 网络编程 Muduo","slug":"C-网络编程-Muduo","permalink":"http://example.com/tags/C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-Muduo/"}]}]